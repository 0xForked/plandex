package handlers

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"log"
	"net/http"
	"plandex-server/db"
	"plandex-server/types"

	"github.com/google/uuid"
	"github.com/plandex/plandex/shared"
)

func loadContexts(w http.ResponseWriter, r *http.Request, auth *types.ServerAuth, loadReq *shared.LoadContextRequest, plan *db.Plan, branchName string) (*shared.LoadContextResponse, []*db.Context) {
	planId := plan.Id

	branch, err := db.GetDbBranch(planId, branchName)
	if err != nil {
		log.Printf("Error getting branch: %v\n", err)
		http.Error(w, "Error getting branch: "+err.Error(), http.StatusInternalServerError)
		return nil, nil
	}

	settings, err := db.GetPlanSettings(plan, true)
	if err != nil {
		log.Printf("Error getting settings: %v\n", err)
		http.Error(w, "Error getting settings: "+err.Error(), http.StatusInternalServerError)
		return nil, nil
	}

	maxTokens := settings.GetPlannerEffectiveMaxTokens()
	tokensAdded := 0
	totalTokens := branch.ContextTokens

	paramsByTempId := make(map[string]*shared.LoadContextParams)
	numTokensByTempId := make(map[string]int)

	for _, context := range *loadReq {
		tempId := uuid.New().String()
		numTokens, err := shared.GetNumTokens(context.Body)

		if err != nil {
			log.Printf("Error getting num tokens: %v\n", err)
			http.Error(w, "Error getting num tokens: "+err.Error(), http.StatusInternalServerError)
			return nil, nil
		}

		paramsByTempId[tempId] = context
		numTokensByTempId[tempId] = numTokens

		tokensAdded += numTokens
		totalTokens += numTokens
	}

	if totalTokens > maxTokens {
		log.Printf("The total number of tokens (%d) exceeds the maximum allowed (%d)", totalTokens, maxTokens)
		res := shared.LoadContextResponse{
			TokensAdded:       tokensAdded,
			TotalTokens:       totalTokens,
			MaxTokens:         maxTokens,
			MaxTokensExceeded: true,
		}

		bytes, err := json.Marshal(res)

		if err != nil {
			log.Printf("Error marshalling response: %v\n", err)
			http.Error(w, "Error marshalling response: "+err.Error(), http.StatusInternalServerError)
			return nil, nil
		}

		w.Write(bytes)
		return nil, nil
	}

	ctx, cancel := context.WithCancel(context.Background())
	unlockFn := lockRepo(w, r, auth, db.LockScopeWrite, ctx, cancel)
	if unlockFn == nil {
		return nil, nil
	} else {
		defer (*unlockFn)(err)
	}

	dbContextsCh := make(chan *db.Context)
	errCh := make(chan error)
	for tempId, params := range paramsByTempId {

		go func(tempId string, params *shared.LoadContextParams) {
			hash := sha256.Sum256([]byte(params.Body))
			sha := hex.EncodeToString(hash[:])

			context := db.Context{
				// Id generated by db layer
				OrgId:       auth.OrgId,
				OwnerId:     auth.User.Id,
				PlanId:      planId,
				ContextType: params.ContextType,
				Name:        params.Name,
				Url:         params.Url,
				FilePath:    params.FilePath,
				NumTokens:   numTokensByTempId[tempId],
				Sha:         sha,
				Body:        params.Body,
			}

			err := db.StoreContext(&context)

			if err != nil {
				errCh <- err
				return
			}

			dbContextsCh <- &context

		}(tempId, params)
	}

	var dbContexts []*db.Context
	var apiContexts []*shared.Context

	for i := 0; i < len(*loadReq); i++ {
		select {
		case err := <-errCh:
			log.Printf("Error creating context: %v\n", err)
			http.Error(w, "Error creating context: "+err.Error(), http.StatusInternalServerError)
			return nil, nil
		case dbContext := <-dbContextsCh:
			dbContexts = append(dbContexts, dbContext)
			apiContext := dbContext.ToApi()
			apiContext.Body = ""
			apiContexts = append(apiContexts, apiContext)
		}
	}

	err = db.AddPlanContextTokens(planId, branchName, tokensAdded)
	if err != nil {
		log.Printf("Error updating plan tokens: %v\n", err)
		http.Error(w, "Error updating plan tokens: "+err.Error(), http.StatusInternalServerError)
		return nil, nil
	}

	commitMsg := shared.SummaryForLoadContext(apiContexts, tokensAdded, totalTokens) + "\n\n" + shared.TableForLoadContext(apiContexts)
	err = db.GitAddAndCommit(auth.OrgId, planId, branchName, commitMsg)

	if err != nil {
		log.Printf("Error committing changes: %v\n", err)
		http.Error(w, "Error committing changes: "+err.Error(), http.StatusInternalServerError)
		return nil, nil
	}

	return &shared.LoadContextResponse{
		TokensAdded: tokensAdded,
		TotalTokens: totalTokens,
		Msg:         commitMsg,
	}, dbContexts
}
